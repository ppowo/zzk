package git

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func CreateIdentityGitConfig(identity Identity) error {
	path := ExpandPath(identity.GitConfigPath())

	content := fmt.Sprintf(`# zzk-managed: %s
# Generated by zzk - Edit ~/.git-identities.json and run 'zzk git sync'
[user]
  name = %s
  email = %s
  signingkey = %s

[core]
  sshCommand = "ssh -i %s"
`, identity.Name, identity.User, identity.Email, identity.SSHKeyPath(), identity.SSHKeyPath())

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write git config: %w", err)
	}

	return nil
}

func IsZZKManagedGitConfig(configPath string) (bool, string) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return false, ""
	}

	content := string(data)
	if !strings.HasPrefix(content, "# zzk-managed:") {
		return false, ""
	}

	lines := strings.Split(content, "\n")
	if len(lines) > 0 {
		firstLine := lines[0]
		parts := strings.SplitN(firstLine, ":", 2)
		if len(parts) == 2 {
			identity := strings.TrimSpace(parts[1])
			return true, identity
		}
	}

	return false, ""
}

func FindZZKManagedGitConfigs() (map[string]string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	entries, err := os.ReadDir(home)
	if err != nil {
		return nil, fmt.Errorf("failed to read home directory: %w", err)
	}

	managedConfigs := make(map[string]string)

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		if !strings.HasPrefix(name, ".gitconfig-") {
			continue
		}

		configPath := filepath.Join(home, name)
		isManaged, identity := IsZZKManagedGitConfig(configPath)
		if isManaged {
			managedConfigs[identity] = configPath
		}
	}

	return managedConfigs, nil
}

func UpdateGlobalGitConfig(config *Config) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	gitConfigPath := filepath.Join(home, ".gitconfig")

	var existingContent string
	if data, err := os.ReadFile(gitConfigPath); err == nil {
		existingContent = string(data)
	}

	existingContent = removeZZKSections(existingContent)

	existingContent = removeLegacyEntries(existingContent, config)

	var zzkContent strings.Builder

	zzkContent.WriteString("\n# zzk:begin:globals\n")
	if !strings.Contains(existingContent, "[gpg]") {
		zzkContent.WriteString("[gpg]\n  format = ssh\n\n")
	}
	if !strings.Contains(existingContent, "[gpg \"ssh\"]") {
		zzkContent.WriteString("[gpg \"ssh\"]\n  allowedSignersFile = ~/.ssh/allowed_signers\n\n")
	}
	if !strings.Contains(existingContent, "[commit]") {
		zzkContent.WriteString("[commit]\n  gpgsign = true\n")
	}
	zzkContent.WriteString("# zzk:end:globals\n\n")

	zzkContent.WriteString("# zzk:begin:url-rewrites\n")
	domains := make(map[string]bool)
	for _, identity := range config.Identities {
		if !domains[identity.Domain] {
			zzkContent.WriteString(fmt.Sprintf("[url \"ssh://git@%s/\"]\n", identity.Domain))
			zzkContent.WriteString(fmt.Sprintf("  insteadOf = https://%s/\n\n", identity.Domain))
			domains[identity.Domain] = true
		}
	}
	zzkContent.WriteString("# zzk:end:url-rewrites\n\n")

	zzkContent.WriteString("# zzk:begin:includes\n")
	for _, identity := range config.Identities {
		for _, folder := range identity.Folders {
			if !strings.HasSuffix(folder, "/") {
				folder = folder + "/"
			}
			zzkContent.WriteString(fmt.Sprintf("[includeIf \"gitdir:%s\"]\n", folder))
			zzkContent.WriteString(fmt.Sprintf("  path = %s\n\n", identity.GitConfigPath()))
		}
	}
	zzkContent.WriteString("# zzk:end:includes\n")

	finalContent := strings.TrimSpace(existingContent) + "\n" + zzkContent.String()

	if err := os.WriteFile(gitConfigPath, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write global git config: %w", err)
	}

	return nil
}

func removeZZKSections(content string) string {
	// (?s) makes . match newlines for multi-line removal
	re := regexp.MustCompile(`(?s)# zzk:begin:[^\n]*\n.*?# zzk:end:[^\n]*\n`)
	content = re.ReplaceAllString(content, "")

	return strings.TrimSpace(content)
}

func removeLegacyEntries(content string, config *Config) string {
	lines := strings.Split(content, "\n")
	var result []string

	managedDomains := make(map[string]bool)
	managedFolders := make(map[string]bool)
	for _, identity := range config.Identities {
		managedDomains[identity.Domain] = true
		for _, folder := range identity.Folders {
			normalizedFolder := folder
			if !strings.HasSuffix(normalizedFolder, "/") {
				normalizedFolder += "/"
			}
			managedFolders[normalizedFolder] = true
		}
	}

	skip := false
	skipLines := 0

	for i := range lines {
		line := lines[i]
		trimmed := strings.TrimSpace(line)

		if strings.HasPrefix(trimmed, "[url \"ssh://git@") {
			for domain := range managedDomains {
				if strings.Contains(trimmed, domain) {
					skip = true
					skipLines = 2
					break
				}
			}
		}

		if strings.HasPrefix(trimmed, "[includeIf \"gitdir:") {
			for folder := range managedFolders {
				if strings.Contains(trimmed, folder) {
					skip = true
					skipLines = 2
					break
				}
			}
		}

		if skip {
			skipLines--
			if skipLines <= 0 {
				skip = false
			}
			continue
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

// removeLegacySSHHosts removes old Host entries for domains we manage
func removeLegacySSHHosts(content string, config *Config) string {
	lines := strings.Split(content, "\n")
	var result []string

	managedDomains := make(map[string]bool)
	for _, identity := range config.Identities {
		managedDomains[identity.Domain] = true
	}

	skip := false
	skipUntilBlank := false

	for i := 0; i < len(lines); i++ {
		line := lines[i]
		trimmed := strings.TrimSpace(line)

		if skipUntilBlank && trimmed == "" {
			skipUntilBlank = false
			skip = false
			continue
		}

		if strings.HasPrefix(trimmed, "Host ") && !skip {
			for domain := range managedDomains {
				if strings.Contains(trimmed, domain) {
					skip = true
					skipUntilBlank = true
					break
				}
			}
		}

		if skip {
			continue
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

// UpdateSSHConfig updates ~/.ssh/config with host entries
func UpdateSSHConfig(config *Config) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	sshDir := filepath.Join(home, ".ssh")
	sshConfigPath := filepath.Join(sshDir, "config")

	if err := os.MkdirAll(sshDir, 0700); err != nil {
		return fmt.Errorf("failed to create .ssh directory: %w", err)
	}

	var existingContent string
	if data, err := os.ReadFile(sshConfigPath); err == nil {
		existingContent = string(data)
	}

	re := regexp.MustCompile(`(?s)# zzk:begin\n.*?# zzk:end\n`)
	existingContent = re.ReplaceAllString(existingContent, "")
	existingContent = strings.TrimSpace(existingContent)

	existingContent = removeLegacySSHHosts(existingContent, config)

	var zzkContent strings.Builder
	zzkContent.WriteString("\n\n# zzk:begin\n")

	domainIdentities := make(map[string]Identity)
	for _, identity := range config.Identities {
		if _, exists := domainIdentities[identity.Domain]; !exists {
			domainIdentities[identity.Domain] = identity
		}
	}

	for domain, identity := range domainIdentities {
		zzkContent.WriteString(fmt.Sprintf("Host %s\n", domain))
		zzkContent.WriteString(fmt.Sprintf("  HostName %s\n", domain))
		zzkContent.WriteString("  User git\n")
		zzkContent.WriteString(fmt.Sprintf("  IdentityFile %s\n", identity.SSHKeyPath()))
		zzkContent.WriteString("  IdentitiesOnly yes\n\n")
	}

	zzkContent.WriteString("# zzk:end\n")

	finalContent := existingContent + zzkContent.String()

	if err := os.WriteFile(sshConfigPath, []byte(finalContent), 0600); err != nil {
		return fmt.Errorf("failed to write SSH config: %w", err)
	}

	return nil
}

// UpdateAllowedSigners updates ~/.ssh/allowed_signers with all identity keys
func UpdateAllowedSigners(config *Config) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	allowedSignersPath := filepath.Join(home, ".ssh", "allowed_signers")

	var content strings.Builder

	for _, identity := range config.Identities {
		pubKeyPath := ExpandPath(identity.SSHPubKeyPath())
		pubKeyData, err := os.ReadFile(pubKeyPath)
		if err != nil {
			continue
		}

		pubKey := strings.TrimSpace(string(pubKeyData))
		parts := strings.SplitN(pubKey, " ", 3)
		if len(parts) >= 2 {
			content.WriteString(fmt.Sprintf("%s %s %s\n", identity.Email, parts[0], parts[1]))
		}
	}

	if err := os.WriteFile(allowedSignersPath, []byte(content.String()), 0600); err != nil {
		return fmt.Errorf("failed to write allowed_signers: %w", err)
	}

	return nil
}
